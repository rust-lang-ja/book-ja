<!--
## Hello, Cargo!
-->

## Hello, Cargo!

<!--
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
*dependencies*.)
-->

CargoはRustのビルドシステム兼パッケージマネージャです。
ほとんどのRustaceanはこのツールを使ってRustプロジェクトを管理しています。
なぜなら、Cargoは多くの仕事、たとえばコードのビルド、コードが依存するライブラリのダウンロード、それらのライブラリのビルドなどを扱ってくれるからです。
（コードが必要とするライブラリのことを*依存*（dependencies）と呼びます）

<!--
The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. So if we had built the “Hello, world!” project with Cargo, it
would only use the part of Cargo that handles building your code. As you write
more complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->

いままでに書いたようなごく単純なRustプログラムには依存がありません。
そのため「Hello, world!」プロジェクトをCargoでビルドしても、Cargoの中のコードをビルドする部分しか使わないでしょう。
より複雑なRustプログラムを書くようになると依存を追加することになりますが、Cargoを使ってプロジェクトを開始したなら、依存の追加もずっと簡単になります。

<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[“Installation”][installation] section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->

Rustプロジェクトの大多数がCargoを使用しているので、これ以降、この本では、あなたもCargoを使用していると想定します。
もし[「インストール」][installation]節で紹介した公式のインストーラを使用したなら、CargoはRustと共にインストールされています。
Rustを他の方法でインストールした場合は、以下のコマンドをターミナルに入れて、Cargoがインストールされているか確認してください。

```console
$ cargo --version
```

<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->

バージョンナンバーが表示されたならインストールされています！
`command not found`などのエラーが表示された場合は、自分がインストールした方法についてのドキュメントを参照して、Cargoを個別にインストールする方法を調べてください。

<!--
### Creating a Project with Cargo
-->

### Cargoでプロジェクトを作成する

<!--
Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->

Cargoを使って新しいプロジェクトを作成し、元の「Hello, world!」プロジェクトとの違いを見ていきましょう。
*projects*ディレクトリ（または自分がコードを保存すると決めた場所）に戻ってください。
それから、OSに関係なく、以下を実行してください。

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

<!--
The first command created a new directory called *hello_cargo*. We’ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->

最初のコマンドは*hello_cargo*という名の新しいディレクトリを作成します。
プロジェクトを*hello_cargo*と名付けたので、Cargoはそれに関連するいくつかのファイルを同名のディレクトリに作成します。

<!--
Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside.
-->

*hello_cargo*ディレクトリに行き、ファイルの一覧を取得してください。
Cargoが2つのファイルと1つのディレクトリを生成してくれたことがわかるでしょう。
*Cargo.toml*ファイルと*src*ディレクトリがあり、*src*の中には*main.rs*ファイルがあります。

<!--
It has also initialized a new Git repository along with a *.gitignore* file.
Git files won’t be generated if you run `cargo new` within an existing Git
repository; you can override this behavior by using `cargo new --vcs=git`.
-->

また、*.gitignore*ファイルと共に新しいGitリポジトリも初期化されています。
もし、すでに存在するGitリポジトリの中で`cargo new`を実行したなら、Git関連のファイルは作られません。
`cargo new --vcs=git`とすることで、この振る舞いを変更できます。

<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->

> 補足：Gitは一般的なバージョン管理システムです。
> `cargo new`コマンドに`--vcs`フラグを与えることで、別のバージョン管理システムを使用したり、何も使用しないようにもできます。
> 利用可能なオプションを確認するには`cargo new --help`を実行します。

<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->

お気に入りのテキストエディタで*Cargo.toml*を開いてください。
リスト1-2のコードのようになっているはずです。

<!--
<span class="filename">Filename: Cargo.toml</span>
-->

<span class="filename">ファイル名：Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
```

<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->

<span class="caption">リスト1-2：`cargo new`で生成された*Cargo.toml*の内容</span>

<!--
This file is in the [*TOML*](https://toml.io) (*Tom’s Obvious,
Minimal Language*) format, which is Cargo’s configuration format.
-->

このファイルは[TOML](https://toml.io)（*Tom's Obvious, Minimal Language*、トムの明確な最小限の言語）形式で、Cargoの設定フォーマットです。

<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.
-->

最初の行の`[package]`はセクションヘッダーで、それ以降の文がパッケージを設定することを示します。
このファイルに情報を追加してく中で、他のセクションも追加していくことになります。

<!--
The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use. We’ll talk
about the `edition` key in [Appendix E][appendix-e].
-->

次の3行はCargoがプログラムをコンパイルするのに必要となる設定情報を指定します。
ここでは、名前、バージョン、使用するRustのエディションを指定しています。
`edition`キーについては[付録E][appendix-e]で説明されています。

<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
*crates*. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.
-->

最後の行の`[dependencies]`は、プロジェクトの依存を列挙するためのセクションの始まりです。
Rustではコードのパッケージのことを*クレート*と呼びます。
このプロジェクトでは他のクレートは必要ありませんが、第2章の最初のプロジェクトでは必要になるので、そのときにこの依存セクションを使用します。

<!--
Now open *src/main.rs* and take a look:
-->

では、*src/main.rs*を開いて見てみましょう。

<!--
<span class="filename">Filename: src/main.rs</span>
-->

<span class="filename">ファイル名: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

<!--
Cargo has generated a “Hello, world!” program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our previous project and
the project Cargo generated are that Cargo placed the code in the *src*
directory, and we have a *Cargo.toml* configuration file in the top directory.
-->

Cargoはリスト1-1で書いたような「Hello, world!」プログラムを生成してくれています。
これまでのところ、以前のプロジェクトとCargoが生成したプロジェクトの違いは、Cargoがコードを*src*ディレクトリに配置したことと、
最上位のディレクトリに*Cargo.toml*設定ファイルがあることです。

<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.
-->

Cargoはソースファイルが*src*ディレクトリにあることを期待します。
プロジェクトの最上位のディレクトリは、READMEファイル、ライセンス情報、設定ファイル、その他のコードに関係しないものだけを置きます。
Cargoを使うとプロジェクトを整理することができます。
すべてのものに決まった場所があり、すべてがその場所にあるのです。

<!--
If you started a project that doesn’t use Cargo, as we did with the “Hello,
world!” project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->

「Hello, world!」プロジェクトのようにCargoを使用しないプロジェクトを開始したときでも、Cargoを使用するプロジェクトへと変換できます。
プロジェクトのコードを*src*ディレクトリに移動し、適切な*Cargo.toml*ファイルを作成すればいいのです。

<!--
### Building and Running a Cargo Project
-->

### Cargoプロジェクトをビルドし、実行する

<!--
Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->

では「Hello, world!」プログラムをCargoでビルドして実行すると、何が違うのかを見てみましょう！
*hello_cargo*ディレクトリから以下のコマンドを入力して、プロジェクトをビルドします。

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->

このコマンドは実行ファイルを現在のディレクトリではなく、*target/debug/hello_cargo*（Windowsでは*target/debug/hello_cargo.exe*）に作成します。
以下のコマンドで実行ファイルを実行できます。

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
$                              # Windowsでは .\target\debug\hello_cargo.exe
Hello, world!
```

<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.
-->

すべてがうまくいけば、ターミナルに`Hello, world!`と表示されるはずです。
`cargo build`を初めて実行したとき、Cargoは最上位に*Cargo.lock*という新しいファイルを作成します。
このファイルはプロジェクト内の依存関係の正確なバージョンを記録しています。
このプロジェクトには依存がないので、このファイルの中は少しまばらです。
このファイルは手動で変更する必要はありません。
Cargoがその内容を管理してくれます。

<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->

先ほどは`cargo build`でプロジェクトをビルドし、`./target/debug/hello_cargo`で実行しました。
`cargo run`を使うと、コードのコンパイルから、できた実行ファイルの実行までの全体を一つのコマンドで行えます。

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

<!--
Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->

今回はCargoが`hello_cargo`をコンパイルしていることを示す出力がないことに注目してください。
Cargoはファイルが変更されていないことに気づいたので、単にバイナリを実行したのです。
もしソースコードを変更していたら、Cargoは実行前にプロジェクトを再ビルドし、以下のような出力が表示されたことでしょう。

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:
-->

Cargoは`cargo check`というコマンドも提供しています。
このコマンドはコードがコンパイルできるか素早くチェックしますが、実行ファイルは生成しません。

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they’re ready to use the executable.
-->

なぜ実行可能ファイルが欲しくないのでしょうか？
`cargo check`は実行ファイルを生成するステップを省くことができるので、多くの場合、`cargo build`よりもずっと高速です。
もし、あなたがコードを書きながら継続的にチェックするのなら、`cargo check`を使えば、そのプロセスを高速化できます！
そのため多くのRustaceanはプログラムを書きながら定期的に`cargo check`を実行し、コンパイルできるか確かめます。
そして、実行ファイルを使う準備ができたときに`cargo build`を走らせるのです。

<!--
Let’s recap what we’ve learned so far about Cargo:
-->

ここまでにCargoについて学んだことをおさらいしておきましょう。

<!--
* We can create a project using `cargo new`.
* We can build a project using `cargo build`.
* We can build and run a project in one step using `cargo run`.
* We can build a project without producing a binary to check for errors using
  `cargo check`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->

* `cargo new`を使ってプロジェクトを作成できる
* `cargo build`を使ってプロジェクトをビルドできる
* `cargo run`を使うとプロジェクトのビルドと実行を1ステップで行える
* `cargo check`を使うとバイナリを生成せずにプロジェクトをビルドして、エラーがないか確認できる
* Cargoは、ビルドの成果物をコードと同じディレクトリに保存するのではなく、*target/debug*ディレクトリに格納する

<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->

Cargoを使用するもう一つの利点は、どのOSで作業していてもコマンドが同じであることです。
そのため、これ以降はLinuxやmacOS向けの手順と、Windows向けの手順を分けて説明することはありません。

<!--
### Building for Release
-->

### リリースに向けたビルド

<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->

プロジェクトが最終的にリリースできるようになったら、`cargo build --release`を使い、最適化した状態でコンパイルできます。
このコマンドは実行ファイルを、*target/debug*ではなく、*target/release*に作成します。
最適化によってRustコードの実行速度が上がりますが、それを有効にすることでプログラムのコンパイルにかかる時間が長くなります。
このため二つの異なるプロファイルがあるのです。
一つは開発用で、素早く頻繁に再ビルドしたいときのもの。
もう一つはユーザに渡す最終的なプログラムをビルドするためのもので、繰り返し再ビルドすることはなく、可能な限り高速に動作するようにします。
コードの実行時間をベンチマークするなら、必ず`cargo build --release`を実行し、*target/release*の実行ファイルを使ってベンチマークを取ってください。

<!--
### Cargo as Convention
-->

### 習慣としてのCargo

<!--
With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build.
-->

単純なプロジェクトでは、Cargoは単に`rustc`を使うことに対してあまり多くの価値を生みません。
しかし、プログラムが複雑になるにつれて、その価値を証明することになるでしょう。
複数のクレートからなる複雑なプロジェクトでは、Cargoにビルドを調整させるほうがずっと簡単です。

<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:
-->

`hello_cargo`プロジェクトは単純ではありますが、Rustのキャリアを通じて使うことになる本物のツールの多くを使用しています。
実際、既存のどんなプロジェクトで作業するときも、以下のコマンドを使えば、Gitでコードをチェックアウトし、そのプロジェクトのディレクトリに移動し、ビルドすることができます。

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

<!--
For more information about Cargo, check out [its documentation].

[its documentation]: https://doc.rust-lang.org/cargo/
-->

Cargoの詳細については、[ドキュメント]を参照してください。

[ドキュメント]: https://doc.rust-lang.org/cargo/

<!--
## Summary
-->

## まとめ

<!--
You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:
-->

既にRustの旅の素晴らしいスタートを切っています！
この章では以下を行う方法について学びました。

<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a “Hello, world!” program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->

* `rustup`で最新の安定版のRustをインストールする
* 新しいRustのバージョンに更新する
* ローカルにインストールされたドキュメントを開く
* 「Hello, world!」プログラムを書き、`rustc`を直接使って実行する
* Cargoにおける習慣に従った新しいプロジェクトを作成し、実行する

<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->

いまは、より中身のあるプログラムを構築し、Rustコードの読み書きに慣れるのに良いタイミングでしょう。
そこで第2章では、数当てゲームプログラムを構築します。
もし、一般的なプログラミングの概念がRustでどう実現されるか学ぶことから始めたいのであれば、第3章を読んで、それから第2章に戻ってください。

<!--
[installation]: ch01-01-installation.html#installation
[appendix-e]: appendix-05-editions.html
-->

[installation]: ch01-01-installation.html#インストール
[appendix-e]: appendix-05-editions.html
