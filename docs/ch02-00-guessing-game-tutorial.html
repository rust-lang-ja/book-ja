<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数当てゲームをプログラムする - The Rust Programming Language 日本語版</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        
        <link rel="stylesheet" href="theme/em-to-bold.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="title-page.html">The Rust Programming Language 日本語版</a></li><li class="expanded affix "><a href="foreword.html">まえがき</a></li><li class="expanded affix "><a href="ch00-00-introduction.html">導入</a></li><li class="expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li class="expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li class="expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="expanded "><a href="ch02-00-guessing-game-tutorial.html" class="active"><strong aria-hidden="true">2.</strong> 数当てゲームをプログラムする</a></li><li class="expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 一般的なプログラミングの概念</a></li><li><ol class="section"><li class="expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li class="expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li class="expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数</a></li><li class="expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li class="expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> フロー制御</a></li></ol></li><li class="expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li class="expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li class="expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li class="expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス型</a></li></ol></li><li class="expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関係のあるデータを構造化する</a></li><li><ol class="section"><li class="expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li class="expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使ったプログラム例</a></li><li class="expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li class="expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li class="expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li class="expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> matchフロー制御演算子</a></li><li class="expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔なフロー制御</a></li></ol></li><li class="expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する</a></li><li><ol class="section"><li class="expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> パッケージとクレート</a></li><li class="expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> モジュールを定義して、スコープとプライバシーを制御する</a></li><li class="expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> モジュールツリーの要素を示すためのパス</a></li><li class="expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> useキーワードでパスをスコープに持ち込む</a></li><li class="expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> モジュールを複数のファイルに分割する</a></li></ol></li><li class="expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li class="expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ベクタで一連の値を保持する</a></li><li class="expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列でUTF-8でエンコードされたテキストを保持する</a></li><li class="expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> キーとそれに紐づいた値をハッシュマップに格納する</a></li></ol></li><li class="expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li class="expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li class="expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li class="expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li class="expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li class="expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li class="expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト：共通の振る舞いを定義する</a></li><li class="expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を検証する</a></li></ol></li><li class="expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 自動テストを書く</a></li><li><ol class="section"><li class="expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストの記述法</a></li><li class="expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストの実行のされ方を制御する</a></li><li class="expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li class="expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト：コマンドラインプログラムを構築する</a></li><li><ol class="section"><li class="expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li class="expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li class="expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリンクしてモジュール性とエラー処理を向上させる</a></li><li class="expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li class="expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li class="expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li class="expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能：イテレータとクロージャ</a></li><li><ol class="section"><li class="expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ：環境をキャプチャできる匿名関数</a></li><li class="expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li class="expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li class="expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較：ループVSイテレータ</a></li></ol></li><li class="expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li class="expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li class="expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li class="expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li class="expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li class="expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoを拡張する</a></li></ol></li><li class="expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li class="expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ヒープのデータを指すBox<T>を使用する</a></li><li class="expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトでスマートポインタを普通の参照のように扱う</a></li><li class="expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトで片付け時にコードを走らせる</a></li><li class="expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>は、参照カウント方式のスマートポインタ</a></li><li class="expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T>と内部可変性パターン</a></li><li class="expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照は、メモリをリークすることもある</a></li></ol></li><li class="expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li class="expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッドを使用してコードを同時に走らせる</a></li><li class="expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡しを使ってスレッド間でデータを転送する</a></li><li class="expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有並行性</a></li><li class="expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> SyncとSendトレイトで拡張可能な並行性</a></li></ol></li><li class="expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li class="expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li class="expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> トレイトオブジェクトで異なる型の値を許容する</a></li><li class="expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li class="expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンとマッチング</a></li><li><ol class="section"><li class="expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されることのある箇所全部</a></li><li class="expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性：パターンが合致しないかどうか</a></li><li class="expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法</a></li></ol></li><li class="expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li class="expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 高度なトレイト</a></li><li class="expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 高度な型</a></li><li class="expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 高度な関数とクロージャ</a></li><li class="expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> マクロ</a></li></ol></li><li class="expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト：マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li class="expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバを構築する</a></li><li class="expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドサーバをマルチスレッド化する</a></li><li class="expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 正常なシャットダウンと片付け</a></li></ol></li><li class="expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li class="expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> 付録A：キーワード</a></li><li class="expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> 付録B：演算子と記号</a></li><li class="expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> 付録C：導出可能なトレイト</a></li><li class="expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> 付録D：便利な開発ツール</a></li><li class="expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> 付録E：Edition</a></li><li class="expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> 付録F：本の翻訳</a></li><li class="expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> 付録G：Rustの作られ方と“Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rust Programming Language 日本語版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# Programming a Guessing Game
-->
<h1><a class="header" href="#数当てゲームをプログラムする" id="数当てゲームをプログラムする">数当てゲームをプログラムする</a></h1>
<!--
Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about `let`, `match`, methods, associated
functions, external crates, and more! The following chapters will explore these
ideas in more detail. In this chapter, you’ll practice the fundamentals.
-->
<p>実物のプロジェクトに一緒に取り組むことで、Rustの世界へ飛び込みましょう！
この章では、実際のプログラム内で使用しながらいくつかの一般的なRustの概念に触れます。
<code>let</code>、<code>match</code>、メソッド、関連関数、外部クレートの使用などについて学ぶでしょう！
後ほどの章でこれらの概念について深く知ることになります。この章では、基礎部分だけにしましょう。</p>
<!--
We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.
-->
<p>古典的な初心者向けのプログラミング問題を実装してみましょう: 数当てゲームです。 
これは以下のように動作します: プログラムは1から100までの乱数整数を生成します。
そしてプレーヤーに予想を入力するよう促します。予想を入力したら、プログラムは、
その予想が小さすぎたか大きすぎたかを出力します。予想が当たっていれば、ゲームは祝福メッセージを表示し、
終了します。</p>
<!--
## Setting Up a New Project
-->
<h2><a class="header" href="#新規プロジェクトの立ち上げ" id="新規プロジェクトの立ち上げ">新規プロジェクトの立ち上げ</a></h2>
<!--
To set up a new project, go to the *projects* directory that you created in
Chapter 1 and make a new project using Cargo, like so:
-->
<p>新規プロジェクトを立ち上げるには、第1章で作成した<em>projects</em>ディレクトリに行き、
Cargoを使って新規プロジェクトを作成します。以下のように:</p>
<pre><code class="language-text">$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<!--
The first command, `cargo new`, takes the name of the project (`guessing_game`)
as the first argument. The `--bin` flag tells Cargo to make a binary project,
like to the one in Chapter 1. The second command changes to the new
project’s directory.
-->
<p>最初のコマンド<code>cargo new</code>は、プロジェクト名を第1引数に取ります(<code>guessing_game</code>ですね)。
<code>--bin</code>というフラグは、Cargoにバイナリ生成プロジェクトを作成させます。第1章のものと似ていますね。
2番目のコマンドで新規プロジェクトのディレクトリに移動します。</p>
<!--
Look at the generated *Cargo.toml* file:
-->
<p>生成された<em>Cargo.toml</em>ファイルを見てください:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;名前 &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<!--
If the author information that Cargo obtained from your environment is not
correct, fix that in the file and save it again.
-->
<p>もし、Cargoがあなたの環境から取得した作者情報が間違っていたら、
ファイルを編集して保存し直してください。</p>
<!--
As you saw in Chapter 1, `cargo new` generates a “Hello, world!” program for
you. Check out the *src/main.rs* file:
-->
<p>第1章でも見かけたように、<code>cargo new</code>コマンドは、&quot;Hello, world!&quot;プログラムを生成してくれます。
<em>src/main.rs</em>ファイルをチェックしてみましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Now let’s compile this “Hello, world!” program and run it in the same step
using the `cargo run` command:
-->
<p>さて、この&quot;Hello, world!&quot;プログラムをコンパイルし、<code>cargo run</code>コマンドを使用して、
以前と同じように動かしてみましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<!--
The `run` command comes in handy when you need to rapidly iterate on a project,
as we'll do in this game, quickly testing each iteration before moving on to
the next one.
-->
<p><code>run</code>コマンドは、プロジェクトに迅速に段階を踏んで取り掛かる必要がある場合に有用であり、
次のステップに進む前に各段階を急速にテストして、このゲームではそれを行います。</p>
<!--
Reopen the *src/main.rs* file. You’ll be writing all the code in this file.
-->
<p>再度<em>src/main.rs</em>ファイルを開きましょう。ここにすべてのコードを書いていきます。</p>
<!--
## Processing a Guess
-->
<h2><a class="header" href="#予想を処理する" id="予想を処理する">予想を処理する</a></h2>
<!--
The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
*src/main.rs*
-->
<p>数当てプログラムの最初の部分は、ユーザに入力を求め、その入力を処理し、予期した形式になっていることを確認します。
手始めに、プレーヤーが予想を入力できるようにしましょう。
リスト2-1のコードを<em>src/main.rs</em>に入力してください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん

    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました

    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
}
</code></pre>
<!--
<span class="caption">Listing 2-1: Code that gets a guess from the user and prints
it</span>
-->
<p><span class="caption">リスト2-1: ユーザに予想を入力してもらい、それを出力するコード</span></p>
<blockquote>
<p>注釈: The programming language Rust第1版の翻訳者によると、
ソースコードのコメント中以外に日本語文字があるとコンパイルに失敗することがあるそうなので、文字列の英語は、コメントに和訳を載せます。
また、重複する内容の場合には、最初の1回だけ掲載するようにします。</p>
</blockquote>
<!--
This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
`io` (input/output) library into scope. The `io` library comes from the
standard library (which is known as `std`):
-->
<p>このコードには、たくさんの情報が詰め込まれていますね。なので、行ごとに見ていきましょう。
ユーザ入力を受け付け、結果を出力するためには、<code>io</code>(入/出力)ライブラリをスコープに導入する必要があります。
<code>io</code>ライブラリは、標準ライブラリ(<code>std</code>として知られています)に存在します:</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<!--
By default, Rust brings only a few types into the scope of every program in
[the *prelude*][prelude]. If a type you want to use isn’t in the
prelude, you have to bring that type into scope explicitly with a `use`
statement. Using the `std::io` library provides you with a number of useful
features, including the ability to accept user input.
-->
<p>デフォルトでは、<a href="../../std/prelude/index.html"><em>prelude</em></a><!-- ignored -->に存在するいくつかの型のみ使えます。
もし、使用したい型がpreludeにない場合は、<code>use</code>文で明示的にその型をスコープに導入する必要があります。
<code>std::io</code>ライブラリを使用することで、ユーザ入力を受け付ける能力などの実用的な機能の多くを使用することができます。</p>
<!--
As you saw in Chapter 1, the `main` function is the entry point into the
program:
-->
<p>第1章で見た通り、<code>main</code>関数がプログラムへのエントリーポイント(<code>脚注</code>: スタート地点)になります:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<!--
The `fn` syntax declares a new function, the parentheses, `()`,  indicate there
are no parameters, and the curly bracket, `{`, starts the body of the function.
-->
<p><code>fn</code>構文が関数を新しく宣言し、かっこの<code>()</code>は引数がないことを示し、波括弧の<code>{</code>が関数本体のスタート地点になります。</p>
<!--
As you also learned in Chapter 1, `println!` is a macro that prints a string to
the screen:
-->
<p>また、第1章で学んだように、<code>println!</code>は、文字列を画面に表示するマクロになります:</p>
<pre><code class="language-rust ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<!--
This code is printing a prompt stating what the game is and requesting
input from the user.
-->
<p>このコードは、このゲームが何かを出力し、ユーザに入力を求めています。</p>
<!--
### Storing Values with Variables
-->
<h3><a class="header" href="#値を変数に保持する" id="値を変数に保持する">値を変数に保持する</a></h3>
<!--
Next, we’ll create a place to store the user input, like this:
-->
<p>次に、ユーザ入力を保持する場所を作りましょう。こんな感じに:</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<!--
Now the program is getting interesting! There’s a lot going on in this little
line. Notice that this is a `let` statement, which is used to create a
*variable*. Here’s another example:
-->
<p>さあ、プログラムが面白くなってきましたね。このたった1行でいろんなことが起きています。
これが<code>let</code>文であることに注目してください。これを使用して<em>変数</em>を生成しています。
こちらは、別の例です:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<!--
This line will create a new variable named `foo` and binds it to the value `bar`.
In Rust, variables are immutable by default. We'll discuss this concept in
detail in the "Variables and Mutability" section in Chapter 3. The following
example shows how to use `mut` before the variable name to make a variable
mutable:
-->
<p>この行では、<code>foo</code>という名前の新しい変数を作成し、<code>bar</code>の値に束縛しています。
Rustでは、変数は標準で不変(immutable)です。この概念について詳しくは、
第3章の「変数と可変性」節で議論します。以下の例には、
変数名の前に<code>mut</code>をつけて変数を可変にする方法が示されています:</p>
<pre><code class="language-rust ignore">let foo = 5; // immutable
let mut bar = 5; // mutable
</code></pre>
<!--
コメント中にコメント終了記号があると、パースに失敗するので、省いています。
> Note: The `//` syntax starts a comment that continues until the end of the
> line. Rust ignores everything in comments, which are discussed in more detail
> in Chapter 3.
-->
<blockquote>
<p>注釈: <code>//</code>という記法は、行末まで続くコメントを記述します。
コンパイラは、コメントを一切無視し、これについても第3章で詳しく議論します。</p>
</blockquote>
<!--
Let’s return to the guessing game program. You now know that `let mut guess`
will introduce a mutable variable named `guess`. On the other side of the equal
sign (`=`) is the value that `guess` is bound to, which is the result of
calling `String::new`, a function that returns a new instance of a `String`.
[`String`][string] is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.
-->
<p>数当てゲームのプログラムに戻りましょう。さあ、<code>let mut guess</code>が<code>guess</code>という名前の可変変数を導入するとわかりましたね。
イコール記号(<code>=</code>)の反対側には、変数<code>guess</code>が束縛される値があります。この値は、
<code>String::new</code>関数の呼び出し結果であり、この関数は、<code>String</code>型のオブジェクトを返します。
<a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore -->型は、標準ライブラリによって提供される文字列型で、
サイズ可変、UTF-8エンコードされたテキスト破片になります。</p>
<!--
The `::` syntax in the `::new` line indicates that `new` is an *associated
function* of the `String` type. An associated function is implemented on a type,
in this case `String`, rather than on a particular instance of a `String`. Some
languages call this a *static method*.
-->
<p><code>::new</code>行にある<code>::</code>という記法は、<code>new</code>が<code>String</code>型の<em>関連関数</em>であることを表しています。
関連関数とは、<code>String</code>型の特定のオブジェクトよりも型(この場合は<code>String</code>)に対して
実装された関数のことであり、<em>静的(スタティック)メソッド</em>と呼ばれる言語もあります。</p>
<!--
This `new` function creates a new, empty string. You’ll find a `new` function
on many types, because it’s a common name for a function that makes a new value
of some kind.
-->
<p>この<code>new</code>関数は、新しく空の文字列を生成します。<code>new</code>関数は、いろんな型に見られます。
なぜなら、何らかの新規値を生成する関数にとってありふれた名前だからです。</p>
<!--
To summarize, the `let mut guess = String::new();` line has created a mutable
variable that is currently bound to a new, empty instance of a `String`. Whew!
-->
<p>まとめると、<code>let mut guess = String::new();</code>という行は、現在、新たに空の<code>String</code>オブジェクトに束縛されている
可変変数を作っているわけです。ふう！</p>
<!--
Recall that we included the input/output functionality from the standard
library with `use std::io;` on the first line of the program. Now we’ll call an
associated function, `stdin`, on `io`:
-->
<p>プログラムの1行目で、<code>use std::io</code>として、標準ライブラリから入/出力機能を取り込んだことを思い出してください。
今度は、<code>io</code>型の<code>stdin</code>関連関数を呼び出しましょう:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<!--
If we hadn't the `use std::io` line at the beginning of the program, we
could have written this function call as `std::io::stdin`. The `stdin` function
returns an instance of [`std::io::Stdin`][iostdin], which is a
type that represents a handle to the standard input for your terminal.
-->
<p>仮に、プログラムの冒頭で<code>use std::io</code>としていなければ、この関数呼び出しは、<code>std::io::stdin</code>と記述していたでしょう。
この<code>stdin</code>関数は、 <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->オブジェクトを返し、この型は、
ターミナルの標準入力へのハンドルを表す型になります。</p>
<!--
The next part of the code, `.read_line(&mut guess)`, calls the
[`read_line`][read_line] method on the standard input handle to
get input from the user. We’re also passing one argument to `read_line`: `&mut
guess`.
-->
<p>その次のコード片、<code>.read_line(&amp;mut guess)</code>は、標準入力ハンドルの<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore -->
メソッドを呼び出して、ユーザから入力を受け付けます。また、<code>read_line</code>メソッドに対して、<code>&amp;mut guess</code>という引数を一つ渡していますね。</p>
<!--
The job of `read_line` is to take whatever the user types into standard input
and place that into a string, so it takes that string as an argument. The
string argument needs to be mutable so the method can change the string’s
content by adding the user input.
-->
<p><code>read_line</code>メソッドの仕事は、ユーザが標準入力したものすべてを取り出し、文字列に格納することなので、
格納する文字列を引数として取ります。この文字列引数は、可変である必要があります。
メソッドがユーザ入力を追記して、文字列の中身を変えられるようにということですね。</p>
<!--
The `&` indicates that this argument is a *reference*, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write `&mut guess` rather than
`&guess` to make it mutable. (Chapter 4 will explain references more
thoroughly.)
-->
<p><code>&amp;</code>という記号は、この引数が<em>参照</em>であることを表し、これのおかげで、データを複数回メモリにコピーせずとも、
コードの複数箇所で同じデータにアクセスできるようになるわけです。参照は複雑な機能であり、
とても安全かつ簡単に参照を使うことができることは、Rustの主要な利点の一つでもあります。
そのような詳細を知らなくても、このプログラムを完成させることはできます。
現時点では、変数のように、参照も標準で不変であることを知っておけばいいでしょう。
故に、<code>&amp;guess</code>と書くのではなく、<code>&amp;mut guess</code>と書いて、可変にする必要があるのです。
(第4章で参照についてより詳細に説明します)</p>
<!--
### Handling Potential Failure with the `Result` Type
-->
<h3><a class="header" href="#result型で失敗の可能性を扱う" id="result型で失敗の可能性を扱う"><code>Result</code>型で失敗の可能性を扱う</a></h3>
<!--
We’re not quite done with this line of code. Although what we've discussed so
far is a single line of text, it’s only the first part of the single logical
line of code. The second part is this method:
-->
<p>まだ、この行は終わりではありませんよ。ここまでに議論したのはテキストでは1行ですが、コードとしての論理行としては、
まだ所詮最初の部分でしかないのです。2番目の部分はこのメソッドです:</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<!--
When you call a method with the `.foo()` syntax, it’s often wise to introduce a
newline and other whitespace to help break up long lines. We could have
written this code as:
-->
<p><code>.foo()</code>という記法で、メソッドを呼び出す時、改行と空白で長い行を分割するのがしばしば賢明です。
今回の場合、こう書くこともできますよね:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<!--
However, one long line is difficult to read, so it’s best to divide it: two
lines for two method calls. Now let’s discuss what this line does.
-->
<p>しかし、長い行は読みづらいものです。なので、分割しましょう: 2回のメソッド呼び出しに、2行です。
さて、この行が何をしているのかについて議論しましょうか。</p>
<!--
As mentioned earlier, `read_line` puts what the user types into the string
we're passing it, but it also returns a value—in this case, an
[`io::Result`][ioresult]. Rust has a number of types named
`Result` in its standard library: a generic [`Result`][result] as
well as specific versions for submodules, such as `io::Result`.
-->
<p>以前にも述べたように、<code>read_line</code>メソッドは、渡された文字列にユーザが入力したものを入れ込むだけでなく、
値も返します(今回は<a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->です)。 Rustには<code>Result</code>と名のついた型が、
標準ライブラリにたくさんあります: 汎用の<a href="../../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->の他、
<code>io::Result</code>などのサブモジュール用に特化したものまで。</p>
<!--
The `Result` types are [*enumerations*][enums], often referred
to as *enums*. An enumeration is a type that can have a fixed set of values,
and those values are called the enum’s *variants*. Chapter 6 will cover enums
in more detail.
-->
<p>この<code>Result</code>型は、<a href="ch06-00-enums.html"><em>列挙型</em></a><!-- ignore -->であり、普通、<em>enum</em>(イーナム)と呼ばれます。
列挙型とは、固定された種類の値を持つ型のことであり、それらの値は、enumの<em>列挙子</em>(variant)と呼ばれます。
enumについては、第6章で詳しく解説します。</p>
<!--
For `Result`, the variants are `Ok` or `Err`. The `Ok` variant indicates
the operation was successful, and inside `Ok` is the successfully generated value.
The `Err` variant means the operation failed, and `Err` contains information
about how and why the operation failed.
-->
<p><code>Result</code>型に関しては、列挙子は<code>Ok</code>か<code>Err</code>です。<code>Ok</code>列挙子は、処理が成功したことを表し、
中に生成された値を保持します。<code>Err</code>列挙子は、処理が失敗したことを意味し、<code>Err</code>は、処理が失敗した過程や、
理由などの情報を保有します。</p>
<!--
The purpose of these `Result` types is to encode error handling information.
Values of the `Result` type, like values of any type, have methods defined on them. An
instance of `io::Result` has an [`expect` method][expect] that
you can call. If this instance of `io::Result` is an `Err` value, `expect` will
cause the program to crash and display the message that you passed as an
argument to `expect`. If the `read_line` method returns an `Err`, it would
likely be the result of an error coming from the underlying operating system.
If this instance of `io::Result` is an `Ok` value, `expect` will take the
return value that `Ok` is holding and return just that value to you so you
could use it. In this case, that value is the number of bytes in what the user
entered into standard input.
-->
<p>これら<code>Result</code>型の目的は、エラー処理の情報をコード化することです。<code>Result</code>型の値も、他の型同様、
メソッドが定義されています。<code>io::Result</code>オブジェクトには、呼び出し可能な<a href="../../std/result/enum.Result.html#method.expect"><code>expect</code>メソッド</a><!-- ignore -->があります。
この<code>io::Result</code>オブジェクトが<code>Err</code>値の場合、<code>expect</code>メソッドはプログラムをクラッシュさせ、
引数として渡されたメッセージを表示します。<code>read_line</code>メソッドが<code>Err</code>を返したら、
恐らく根底にあるOSによるエラーに起因するのでしょう。
この<code>io::Result</code>オブジェクトが<code>Ok</code>値の場合、<code>expect</code>メソッドは、<code>Ok</code>列挙子が保持する
返り値を取り出して、ただその値を返すので、これを使用することができるでしょう。
今回の場合、その返り値とは、ユーザが標準入力に入力したデータのバイト数になります。</p>
<!--
If you don’t call `expect`, the program will compile, but we’ll get a warning:
-->
<p>もし、<code>expect</code>メソッドを呼び出さなかったら、コンパイルは通るものの、警告が出るでしょう:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
(警告: 使用されなければならない`std::result::Result`が使用されていません)
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<!--
Rust warns that we haven’t used the `Result` value returned from `read_line`,
indicating that the program hasn’t handled a possible error.
-->
<p>コンパイラは、私たちが<code>read_line</code>メソッドから返ってきた<code>Result</code>値を使用していないと警告してきており、
これは、プログラムがエラーの可能性に対処していないことを示します。</p>
<!--
The right way to suppress the warning is to actually write error handling, but
because you just want to crash this program when a problem occurs, you can use
`expect`. You'll learn about recovering from errors in Chapter 9.
-->
<p>警告を抑制する正しい手段は、実際にエラー対処コードを書くことですが、今は、
問題が起きた時にプロラグムをクラッシュさせたいので、<code>expect</code>を使用できるわけです。
エラーから復旧する方法については、第9章で学ぶでしょう。</p>
<!--
### Printing Values with `println!` Placeholders
-->
<h3><a class="header" href="#printlnマクロのプレースホルダーで値を出力する" id="printlnマクロのプレースホルダーで値を出力する"><code>println!</code>マクロのプレースホルダーで値を出力する</a></h3>
<!--
Aside from the closing curly brackets, there’s only one more line to discuss in
the code added so far, which is the following:
-->
<p>閉じ波かっこを除けば、ここまでに追加されたコードのうち議論すべきものは、残り1行であり、それは以下の通りです:</p>
<pre><code class="language-rust ignore">println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<!--
This line prints the string we saved the user’s input in. The set of curly
brackets, `{}`, is a placeholder: think of `{}` as little crab pincers that
hold a value in place. You can print more than one value using curly brackets:
the first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to `println!` would look like this:
-->
<p>この行は、ユーザ入力を保存した文字列の中身を出力します。1組の波括弧の<code>{}</code>は、プレースホルダーの役目を果たします:
<code>{}</code>は値を所定の場所に保持する小さなカニのはさみと考えてください。波括弧を使って一つ以上の値を出力できます:
最初の波括弧の組は、フォーマット文字列の後に列挙された最初の値に対応し、
2組目は、2つ目の値、とそんな感じで続いていきます。1回の<code>println!</code>の呼び出しで複数の値を出力するコードは、
以下のような感じになります:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
This code would print `x = 5 and y = 10`.
-->
<p>このコードは、<code>x = 5 and y = 10</code>と出力するでしょう.</p>
<!--
### Testing the First Part
-->
<h3><a class="header" href="#最初の部分をテストする" id="最初の部分をテストする">最初の部分をテストする</a></h3>
<!--
Let’s test the first part of the guessing game. Run it using `cargo run`:
-->
<p>数当てゲームの最初の部分をテストしてみましょう。<code>cargo run</code>でプログラムを走らせてください:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<!--
At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.
-->
<p>ここまでで、ゲームの最初の部分は完成になります: キーボードからの入力を受け付け、出力できています。</p>
<!--
## Generating a Secret Number
-->
<h2><a class="header" href="#秘密の数字を生成する" id="秘密の数字を生成する">秘密の数字を生成する</a></h2>
<!--
Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. Let’s use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a [`rand` crate][randcrate].
-->
<p>次に、ユーザが数当てに挑戦する秘密の数字を生成する必要があります。毎回この秘密の数字は、変わるべきです。
ゲームが何回も楽しめるようにですね。ゲームが難しくなりすぎないように、1から100までの乱数を使用しましょう。
Rustの標準ライブラリには、乱数機能はまだ含まれていません。ですが、実は、
Rustの開発チームが<a href="https://crates.io/crates/rand"><code>rand</code>クレート</a>を用意してくれています。</p>
<!--
### Using a Crate to Get More Functionality
-->
<h3><a class="header" href="#クレートを使用して機能を追加する" id="クレートを使用して機能を追加する">クレートを使用して機能を追加する</a></h3>
<!--
Remember that a crate is a package of Rust code. The project we’ve been
building is a *binary crate*, which is an executable. The `rand` crate is a
*library crate*, which contains code intended to be used in other programs.
-->
<p>クレートはRustコードのパッケージであることを思い出してください。私たちがここまで作ってきたプロジェクトは、
<em>バイナリクレート</em>であり、これは実行可能形式になります。<code>rand</code>クレートは<em>ライブラリクレート</em>であり、
他のプログラムで使用するためのコードが含まれています。</p>
<!--
Cargo’s use of external crates is where it really shines. Before we can write
code that uses `rand`, we need to modify the *Cargo.toml* file to include the
`rand` crate as a dependency. Open that file now and add the following line to
the bottom beneath the `[dependencies]` section header that Cargo created for
you:
-->
<p>外部クレートを使用する部分は、Cargoがとても輝くところです。<code>rand</code>を使ったコードを書ける前に、
<em>Cargo.toml</em>ファイルを編集して、<code>rand</code>クレートを依存ファイルとして取り込む必要があります。
今このファイルを開いて、以下の行をCargoが自動生成した<code>[dependencies]</code>セクションヘッダの一番下に追記しましょう:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<!--
In the *Cargo.toml* file, everything that follows a header is part of a section
that continues until another section starts. The `[dependencies]` section is
where you tell Cargo which external crates your project depends on and which
versions of those crates you require. In this case, we’ll specify the `rand`
crate with the semantic version specifier `0.3.14`. Cargo understands [Semantic
Versioning][semver] (sometimes called *SemVer*), which is a
standard for writing version numbers. The number `0.3.14` is actually shorthand
for `^0.3.14`, which means “any version that has a public API compatible with
version 0.3.14.”
-->
<p><em>Cargo.toml</em>ファイルにおいて、ヘッダに続くものは全て、他のセクションが始まるまで続くセクションの一部になります。
<code>[dependecies]</code>セクションは、プロジェクトが依存する外部クレートと必要とするバージョンを記述するところです。
ここでは、<code>rand</code>クレートで、セマンティックバージョン指定子には<code>0.3.14</code>を指定します。Cargoは、
バージョンナンバー記述の標準規格である<a href="http://semver.org">セマンティックバージョニング</a><!-- ignore --> (時に<em>SemVer</em>と呼ばれる)を理解します。
<code>0.3.14</code>という数字は、実際には<code>^0.3.14</code>の省略記法で、これは、「バージョン0.3.14と互換性のある公開APIを持つ任意のバージョン」を意味します。</p>
<!--
Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.
-->
<p>さて、コードは一切変えずに、リスト2-2のようにプロジェクトをビルドしましょう。</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index` (レジストリを更新しています)
 Downloading rand v0.3.14                                            (rand v0.3.14をダウンロードしています)
 Downloading libc v0.2.14                                            (libc v0.2.14をダウンロードしています)
   Compiling libc v0.2.14                                            (libc v0.2.14をコンパイルしています)
   Compiling rand v0.3.14                                            (rand v0.3.14をコンパイルしています)
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)   (guessing_game v0.1.0をコンパイルしています)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs    
</code></pre>
<!--
<span class="caption">Listing 2-2: The output from running `cargo build` after
adding the rand crate as a dependency</span>
-->
<p><span class="caption">リスト2-2: randクレートを依存として追加した後の<code>cargo build</code>コマンドの出力</span></p>
<!--
You may see different version numbers (but they will all be compatible with
the code, thanks to SemVer!), and the lines may be in a different order.
-->
<p>もしかしたら、バージョンナンバーは違うかもしれません(でも、互換性はあります、SemVerのおかげでね！)。
そして、行の出力順序も違うかもしれません。</p>
<!--
Now that we have an external dependency, Cargo fetches the latest versions of
everything from the *registry*, which is a copy of data from
[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem post
their open source Rust projects for others to use.
-->
<p>今や、外部依存を持つようになったので、Cargoは<em>レジストリ</em>(registry、登録所)から最新バージョンを拾ってきます。
<em>レジストリ</em>とは、<a href="https://crates.io">Crates.io</a>のデータのコピーです。Crates.ioとは、Rustのエコシステムにいる人間が、
他の人が使えるように自分のオープンソースのRustプロジェクトを投稿する場所です。</p>
<!--
After updating the registry, Cargo checks the `[dependencies]` section and
downloads any crates you don’t have yet. In this case, although we only listed
`rand` as a dependency, Cargo also grabbed a copy of `libc`, because `rand`
depends on `libc` to work. After downloading the crates, Rust compiles them and
then compiles the project with the dependencies available.
-->
<p>レジストリの更新後、Cargoは<code>[dependencies]</code>セクションをチェックし、まだ取得していないクレートを全部ダウンロードします。
今回の場合、<code>rand</code>しか依存ファイルには列挙していませんが、Cargoは<code>libc</code>のコピーも拾ってきます。
<code>rand</code>クレートが<code>libc</code>に依存しているからですね。クレートのダウンロード完了後、コンパイラは依存ファイルをコンパイルし、
依存が利用可能な状態でプロジェクトをコンパイルします。</p>
<!--
If you immediately run `cargo build` again without making any changes, you
won't get any output aside from the `Finished` line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven't changed anything
about them in your *Cargo.toml* file. Cargo also knows that you haven't changed
anything about your code, so it doesn't recompile that either. With nothing to
do, it simply exits.
-->
<p>何も変更せず即座に<code>cargo build</code>コマンドを走らせたら、<code>Finished</code>行を除いて何も出力されないでしょう。
Cargoは、既に全ての依存をダウンロードしてコンパイル済みであることも、
あなたが<em>Cargo.toml</em>ファイルを弄ってないことも知っているからです。さらに、Cargoはプログラマがコードを変更していないことも検知するので、
再度コンパイルすることもありません。することがないので、ただ単に終了します。</p>
<!--
If you open up the *src/main.rs* file, make a trivial change, and then save it
and build again, you’ll only see two line of output:
-->
<p><em>src/main.rs</em>ファイルを開き、些細な変更をし、保存して再度ビルドを行えば、2行だけ出力があるでしょう:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!--
These lines show Cargo only updates the build with your tiny change to the
*src/main.rs* file. Your dependencies haven't changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those. It just rebuilds
your part of the code.
-->
<p>これらの行は、Cargoが<em>src/main.rs</em>ファイルへの取るに足らない変更に対して、ビルドを更新していることを示しています。
依存は変更していないので、Cargoは、既にダウンロードしてコンパイルまで済ませてある依存を使用できると検知します。
自分で書いたコードのみ再ビルドをかけるわけです。</p>
<!--
#### Ensuring Reproducible Builds with the *Cargo.lock* File
-->
<h4><a class="header" href="#cargolockファイルで再現可能なビルドを保証する" id="cargolockファイルで再現可能なビルドを保証する"><em>Cargo.lock</em>ファイルで再現可能なビルドを保証する</a></h4>
<!--
Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, what
happens if next week version 0.3.15 of the `rand` crate comes out and contains
an important bug fix but also contains a regression that will break your code?
-->
<p>Cargoは、プログラマが自分のコードを更新するたびに同じ生成物を再構成することを保証してくれるメカニズムを備えています: Cargoは、プログラマが示唆するまで、指定したバージョンの依存のみを使用します。
例として、<code>rand</code>クレートの次週のバージョン0.3.15が登場し、重要なバグ修正がなされているけれども、
自分のコードを破壊してしまう互換性破壊があった場合はどうなるでしょう？</p>
<!--
The answer to this problem is the *Cargo.lock* file, which was created the
first time you ran `cargo build` and is now in your *guessing_game* directory.
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the *Cargo.lock* file. When you build your project in the future, Cargo will
see that the *Cargo.lock* file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at `0.3.14` until you explicitly upgrade, thanks to the *Cargo.lock*
file.
-->
<p>この問題に対する回答は、<em>Cargo.lock</em>ファイルであり、このファイルは、初めて<code>cargo build</code>コマンドを
走らせた時に生成され、現在<em>guessing_game</em>ディレクトリに存在しています。プロジェクトを初めてビルドする際に、
Cargoは判断基準(criteria)に合致するよう全ての依存のバージョンを計算し、<em>Cargo.lock</em>ファイルに記述します。
次にプロジェクトをビルドする際には、Cargoは<em>Cargo.lock</em>ファイルが存在することを確かめ、
再度バージョンの計算の作業を行うのではなく、そこに指定されているバージョンを使用します。
このことにより、自動的に再現可能なビルドを構成できるのです。つまり、明示的にアップグレードしない限り、
プロジェクトが使用するバージョンは<code>0.3.14</code>に保たれるのです。<em>Cargo.lock</em>ファイルのおかげでね。</p>
<!--
#### Updating a Crate to Get a New Version
-->
<h4><a class="header" href="#クレートを更新して新バージョンを取得する" id="クレートを更新して新バージョンを取得する">クレートを更新して新バージョンを取得する</a></h4>
<!--
When you *do* want to update a crate, Cargo provides another command, `update`,
which will ignore the *Cargo.lock* file and figure out all the latest versions
that fit your specifications in *Cargo.toml*. If that works, Cargo will write
those versions to the *Cargo.lock* file
-->
<p>クレートを<em>本当に</em>アップグレードする必要が出てきたら、Cargoは別のコマンド(<code>update</code>)を提供します。
これは、<em>Cargo.lock</em>ファイルを無視して、<em>Cargo.toml</em>ファイル内の全ての指定に合致する最新バージョンを計算します。
それがうまくいったら、Cargoはそれらのバージョンを<em>Cargo.lock</em>ファイルに記述します。</p>
<!--
But by default, Cargo will only look for versions larger than `0.3.0` and
smaller than `0.4.0`. If the `rand` crate has released two new versions,
`0.3.15` and `0.4.0`, you would see the following if you ran `cargo update`:
-->
<p>しかし標準でCargoは、<code>0.3.0</code>より大きく、<code>0.4.0</code>未満のバージョンのみを検索します。
<code>rand</code>クレートの新バージョンが2つリリースされていたら(<code>0.3.15</code>と<code>0.4.0</code>だとします)、
<code>cargo update</code>コマンドを走らせた時に以下のようなメッセージを目の当たりにするでしょう:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    (レジストリ`https://github.com/rust-lang/crates-io-index`を更新しています)
    Updating rand v0.3.14 -&gt; v0.3.15
    (randクレートをv0.3.14 -&gt; v0.3.15に更新しています)
</code></pre>
<!--
At this point, you would also notice a change in your *Cargo.lock* file noting
that the version of the `rand` crate you are now using is `0.3.15`.
-->
<!--
ちょっとこなれた日本語にしづらい英文
-->
<p>この時点で、<em>Cargo.lock</em>ファイルに書かれている現在使用している<code>rand</code>クレートのバージョンが、
<code>0.3.15</code>になっていることにも気付くでしょう。</p>
<!--
If you wanted to use `rand` version `0.4.0` or any version in the `0.4.x`
series, you’d have to update the *Cargo.toml* file to look like this instead:
-->
<p><code>rand</code>のバージョン<code>0.4.0</code>または、<code>0.4.x</code>シリーズのどれかを使用したかったら、
代わりに<em>Cargo.toml</em>ファイルを以下のように更新しなければならないでしょう:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<!--
The next time you run `cargo build`, Cargo will update the registry of crates
available and reevaluate your `rand` requirements according to the new version
you have specified.
-->
<p>次回、<code>cargo build</code>コマンドを走らせたら、Cargoは利用可能なクレートのレジストリを更新し、
<code>rand</code>クレートの必要条件を指定した新しいバージョンに従って再評価します。</p>
<!--
There’s a lot more to say about [Cargo][doccargo] and [its
ecosystem][doccratesio] which we'll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.
-->
<p>まだ第14章で議論する<a href="http://doc.crates.io">Cargo</a><!-- ignore -->と<a href="http://doc.crates.io/crates-io.html">そのエコシステム</a><!-- ignore -->については述べたいことが山ほどありますが、
とりあえずは、これで知っておくべきことは全てです。
Cargoのおかげでライブラリはとても簡単に再利用ができるので、
Rustaceanは数多くのパッケージから構成された小規模のプロジェクトを書くことができるのです。</p>
<!--
### Generating a Random Number
-->
<h3><a class="header" href="#乱数を生成する" id="乱数を生成する">乱数を生成する</a></h3>
<!--
Now that you've added the `rand` crate to *Cargo.toml*, let's start using
`rand`. The next step is to update *src/main.rs*, as shown in Listing 2-3.
-->
<p><em>Cargo.toml</em>に<code>rand</code>クレートを追加したので、<code>rand</code>クレートを使用開始しましょう。
次のステップは、リスト2-3のように<em>src/main.rs</em>ファイルを更新することです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);    //秘密の数字は次の通り: {}

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<!--
<span class="caption">Listing 2-3: Adding code to generate a
random number</span>
-->
<p><span class="caption">リスト2-3: 乱数を生成するコードの追加</span></p>
<!--
First, we add a line that lets Rust know we’ll be using the `rand` crate as an
external dependency. This also does the equivalent of calling `use rand`, so
now we can call anything in the `rand` crate by placing `rand::` before it.
-->
<p>まず、コンパイラに<code>rand</code>クレートを外部依存として使用することを知らせる行を追加しています。
これにより、<code>use rand</code>を呼ぶのと同じ効果が得られるので、<code>rand</code>クレートのものを<code>rand::</code>という接頭辞をつけて呼び出せるようになりました。</p>
<!--
Next, we add another `use` line: `use rand::Rng`. The `Rng` trait defines
methods that random number generators implement, and this trait must be in
scope for us to use those methods. Chapter 10 will cover traits in detail.
-->
<p>次に、別の<code>use</code>行を追加しています: <code>use rand::Rng</code>ですね。<code>Rng</code>トレイトは乱数生成器が実装するメソッドを定義していて、
このトレイトがスコープにないと、メソッドを使用できないのです。トレイトについて詳しくは、
第10章で解説します。</p>
<!--
Also, we’re adding two more lines in the middle. The `rand::thread_rng` function
will give us the particular random number generator that we’re going to use:
one that is local to the current thread of execution and seeded by the
operating system. Next, we call the `gen_range` method on the random number
generator. This method is defined by the `Rng` trait that we brought into
scope with the `use rand::Rng` statement. The `gen_range` method takes two
numbers as arguments and generates a random number between them. It’s inclusive
on the lower bound but exclusive on the upper bound, so we need to specify `1`
and `101` to request a number between 1 and 100.
-->
<p>また、途中に2行追加もしています。<code>rand::thread_rng</code>関数は、これから使う特定の乱数生成器を返してくれます: この乱数生成器は、実行スレッドに固有で、OSにより、シード値を与えられています。
次に、この乱数生成器の<code>gen_range</code>メソッドを呼び出しています。このメソッドは、
<code>use rand::Rng</code>文でスコープに導入した<code>Rng</code>トレイトで定義されています。<code>gen_range</code>メソッドは二つの数字を引数に取り、
それらの間の乱数を生成してくれます。範囲は下限値を含み、上限値を含まないため、<code>1</code>と<code>101</code>と指定しないと1から100の範囲の数字は得られません。</p>
<!--
Note: You won’t just know which traits to use and which methods and functions
to call from a crate. Instructions for using a crate are in each crate’s
documentation. Another neat feature of Cargo is that you can run the `cargo
doc --open` command, which will build documentation provided by all of your
dependencies locally and open it in your browser. If you’re interested in
other functionality in the `rand` crate, for example, run `cargo doc --open`
and click `rand` in the sidebar on the left.
-->
<blockquote>
<p>注釈: 単純に使用すべきトレイトと、クレートからどのメソッドと関数を呼び出すか知っているわけではないでしょう。
クレートの使用方法は、各クレートのドキュメントにあります。Cargoの別の素晴らしい機能は、
<code>cargo doc --open</code>コマンドを走らせてローカルに存在する依存すべてのドキュメントをビルドし、ブラウザで閲覧できる機能です。
例えば、<code>rand</code>クレートの他の機能に興味があるなら、<code>cargo doc --open</code>コマンドを走らせて、
左側のサイドバーから<code>rand</code>をクリックしてください。</p>
</blockquote>
<!--
The second line that we added to the code prints the secret number. This is
useful while we’re developing the program to be able to test it, but we’ll
delete it from the final version. It’s not much of a game if the program prints
the answer as soon as it starts!
-->
<p>コードに追加した2行目は、秘密の数字を出力してくれます。これは、プログラムを開発中にはテストするのに役立ちますが、
最終版からは削除する予定です。プログラムがスタートと同時に答えを出力しちゃったら、ゲームになりませんからね！</p>
<!--
Try running the program a few times:
-->
<p>試しに何回かプログラムを走らせてみてください:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!                         (何回も出ているので、ここでは和訳は省略します)
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<!--
You should get different random numbers, and they should all be numbers between
1 and 100. Great job!
-->
<p>毎回異なる乱数が出て、その数字はすべて1から100の範囲になるはずです。よくやりました！</p>
<!--
## Comparing the Guess to the Secret Number
-->
<h2><a class="header" href="#予想と秘密の数字を比較する" id="予想と秘密の数字を比較する">予想と秘密の数字を比較する</a></h2>
<!--
Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won't compile quite yet, as we
will explain.
-->
<p>今や、ユーザ入力と乱数生成ができるようになったので、比較することができますね。
このステップはリスト2-4に示されています。これから説明するように、このコードは現状ではコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // ---snip---

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),       //小さすぎ！
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),      //大きすぎ！
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),        //やったね！
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span>
-->
<p><span class="caption">リスト2-4: 2値比較の可能性のある返り値を処理する</span></p>
<!--
The first new bit here is another `use` statement, bringing a type called
`std::cmp::Ordering` into scope from the standard library. Like `Result`,
`Ordering` is another enum, but the variants for `Ordering` are `Less`,
`Greater`, and `Equal`. These are the three outcomes that are possible when you
compare two values.
-->
<p>最初の新しい点は、別の<code>use</code>文です。これで、<code>std::cmp::Ordering</code>という型を標準ライブラリからスコープに導入しています。
<code>Result</code>と同じく<code>Ordering</code>もenumです。ただ、<code>Ordering</code>の列挙子は、
<code>Less</code>、<code>Greater</code>、<code>Equal</code>です。これらは、2値比較した時に発生しうる3種類の結果です。</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<!--
Then we add five new lines at the bottom that use the `Ordering` type. The
`cmp` method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the `guess` to the `secret_number`. Then it returns a variant of the
`Ordering` enum we brought into scope with the `use` statement. We use a
[`match`][match] expression to decide what to do next based on
which variant of `Ordering` was returned from the call to `cmp` with the values
in `guess` and `secret_number`.
-->
<p>それから、一番下に新しく5行追加して<code>Ordering</code>型を使用しています。<code>cmp</code>メソッドは、
2値を比較し、比較できるものに対してなら何に対しても呼び出せます。このメソッドは、
比較したいものへの参照を取ります: ここでは、<code>guess</code>変数と<code>secret_number</code>変数を比較しています。
それからこのメソッドは<code>use</code>文でスコープに導入した<code>Ordering</code>列挙型の値を返します。 
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->式を使用して、<code>guess</code>変数と<code>secret_number</code>を<code>cmp</code>に渡して返ってきた<code>Ordering</code>の列挙子に基づき、
次の動作を決定しています。</p>
<!--
A `match` expression is made up of *arms*. An arm consists of a *pattern* and
the code that should be run if the value given to the beginning of the `match`
expression fits that arm’s pattern. Rust takes the value given to `match` and
looks through each arm’s pattern in turn. The `match` construct and patterns
are powerful features in Rust that let you express a variety of situations your
code might encounter and helps ensure that you handle them all. These features
will be covered in detail in Chapter 6 and Chapter 18, respectively.
-->
<p><code>match</code>式は、複数の<em>アーム</em>(腕)からできています。一つのアームは、
パターンとそのパターンに<code>match</code>式の冒頭で与えた値がマッチした時に走るコードから構成されています。Rustは、
<code>match</code>に与えられた値を取り、各アームのパターンを順番に照合していきます。<code>match</code>式とパターンは、
コードを書く際に出くわす様々なシチュエーションを表現させてくれ、
すべてのシチュエーションに対処していることを保証するのを手助けしてくれるRustの強力な機能です。
これらの機能は、それぞれ、第6章と第18章で詳しく講義することにします。</p>
<!--
Let’s walk through an example of what would happen with the `match` expression
used here. Say that the user has guessed 50 and the randomly generated secret
number this time is 38. When the code compares 50 to 38, the `cmp` method will
return `Ordering::Greater`, because 50 is greater than 38. The `match`
expression gets the `Ordering::Greater value and starts checking each arm's
pattern. It looks at the first arm's pattern, `Ordering::Less`, and sees that
the value `Ordering::Greater` does not match `Ordering::Less`, so it ignores
the code in that arm and moves to the next arm. The next arm’s pattern,
`Ordering::Greater`, *does* match `Ordering::Greater`! The associated code in
that arm will execute and print `Too big!` to the screen. The `match`
expression ends because it has no need to look at the last arm in this scenario.
-->
<p>ここで使われている<code>match</code>式でどんなことが起こるかの例をじっくり観察してみましょう！例えば、
ユーザは50と予想し、ランダム生成された秘密の数字は今回、38だったとしましょう。コードが50と38を比較すると、
<code>cmp</code>メソッドは<code>Ordering::Greater</code>を返します。50は38よりも大きいからですね。
<code>match</code>式に<code>Ordering::Greater</code>が与えられ、各アームのパターンを吟味し始めます。まず、
最初のアームのパターンと照合します(<code>Ordering::Less</code>ですね)。しかし、
値の<code>Ordering::Greater</code>と<code>Ordering::Less</code>はマッチしないため、このアームのコードは無視され、
次のアームに移ります。次のアームのパターン、<code>Ordering::Greater</code>は<em>見事に</em><code>Ordering::Greater</code>とマッチします！
このアームに紐づけられたコードが実行され、画面に<code>Too big!</code>が表示されます。
これで<code>match</code>式の実行は終わりになります。この筋書きでは、最後のアームと照合する必要はもうないからですね。</p>
<!--
However, the code in Listing 2-4 won’t compile yet. Let’s try it:
-->
<p>ところが、リスト2-4のコードは、まだコンパイルが通りません。試してみましょう:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types          (型が合いません)
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |                                    (構造体`std::string::String`を予期したけど、整数型変数が見つかりました)
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error   (先のエラーのため、処理を中断します)
Could not compile `guessing_game`.      (`guessing_game`をコンパイルできませんでした)
</code></pre>
<!--
The core of the error states that there are *mismatched types*. Rust has a
strong, static type system. However, it also has type inference. When we wrote
`let guess = String::new()`, Rust was able to infer that `guess` should be a
`String` and didn’t make us write the type. The `secret_number`, on the other
hand, is a number type. A few number types can have a value between 1 and 100:
`i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a 64-bit
number; as well as others. Rust defaults to an `i32`, which is the type of
`secret_number` unless we add type information elsewhere that would cause Rust
to infer a different numerical type. The reason for the error is that Rust
cannot compare a string and a number type.
-->
<p>このエラーの核は、<em>型の不一致</em>があると言っています。Rustには、強い静的型システムがあります。
しかし、型推論にも対応しています。<code>let guess = String::new()</code>と書いた時、コンパイラは、
<code>guess</code>が<code>String</code>型であるはずと推論してくれ、その型を明示させられることはありませんでした。
一方で、<code>secret_number</code>変数は、数値型です。1から100を表すことができる数値型はいくつかあります:
<code>i32</code>は32ビットの数字; <code>u32</code>は32ビットの非負数字; <code>i64</code>は64ビットの数字などです。
Rustでの標準は、<code>i32</code>型であり、型情報をどこかに追加して、コンパイラに異なる数値型だと推論させない限り、
<code>secret_number</code>の型はこれになります。エラーの原因は、Rustでは、文字列と数値型を比較できないことです。</p>
<!--
Ultimately, we want to convert the `String` the program reads as input into a
real number type so we can compare it numerically to the guess. We can do that
by adding the following two lines to the `main` function body:
-->
<p>究極的には、プログラムが入力として読み込む<code>String</code>型を現実の数値型に変換し、
予想と数値として比較できるようにしたいわけです。これは、以下の2行を<code>main</code>関数の本体に追記することでできます:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);                 //数値を入力してください！

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<!--
The two new lines are:
-->
<p>その2行とは:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<!--
We create a variable named `guess`. But wait, doesn’t the program already have
a variable named `guess`? It does, but Rust allows us to *shadow* the previous
value of `guess` with a new one. This feature is often used in sutuations in
which you want to convert a value from one type to another type. Shadowing lets
us reuse the `guess` variable name rather than forcing us to create two unique
variables, such as `guess_str` and `guess` for example. (Chapter 3 covers
shadowing in more detail.)
-->
<p><code>guess</code>という名前の変数を生成しています。あれ、でも待って。もうプログラムには<code>guess</code>という名前の変数がありませんでしたっけ？
確かにありますが、Rustでは、新しい値で<code>guess</code>の値を<em>覆い隠す</em>(shadow)ことが許されているのです。
この機能は、値を別の型に変換したいシチュエーションでよく使われます。
シャドーイング(shadowing)のおかげで別々の変数を2つ作らされることなく、<code>guess</code>という変数名を再利用することができるのです。
<code>guess_str</code>と<code>guess</code>みたいなね(シャドーイングについては、第3章でもっと掘り下げます)。</p>
<!--
We bind `guess` to the expression `guess.trim().parse()`. The `guess` in the
expression refers to the original `guess` that was a `String` with the input in
it. The `trim` method on a `String` instance will eliminate any whitespace at
the beginning and end. Although `u32` can contain only numerical characters,
the user must press the <span class="keystroke">enter</span> to satisfy
`read_line`. When the user presses <span class="keystroke">enter</span>, a
newline character is added to the string. For example, if the user types <span
class="keystroke">5</span> and presses <span class="keystroke">enter</span>,
`guess` looks like this: `5\n`. The `\n` represents “newline,” the result of
pressing <span class="keystroke">enter</span>. The `trim` method eliminates
`\n`, resulting in just `5`.
-->
<p><code>guess</code>を<code>guess.trim().parse()</code>という式に束縛しています。この式中の<code>guess</code>は、
入力が入った<code>String</code>型の元々の<code>guess</code>を指しています。<code>String</code>オブジェクトの<code>trim</code>メソッドは、
両端の空白をすべて除去します。<code>u32</code>型は、数字しか含むことができませんが、ユーザは、
<code>read_line</code>の処理を終えるために<span class="keystroke">エンター</span>を押さなければなりません。
ユーザが<span class="keystroke">エンター</span>を押したら、改行文字が文字列に追加されます。
具体例として、ユーザが<span class="keystroke">5</span>を入力して、
<span class="keystroke">エンター</span>を押せば、<code>guess</code>は次のようになります: <code>5\n</code>。
この<code>\n</code>が「改行」、つまりエンターキーを押した結果を表しているわけです。
<code>trim</code>メソッドは、<code>\n</code>を削除するので、ただの<code>5</code>になります。</p>
<!--
The [`parse` method on strings][parse] parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using `let guess: u32`. The
colon (`:`) after `guess` tells Rust we’ll annotate the variable’s type. Rust
has a few built-in number types; the `u32` seen here is an unsigned, 32-bit
integer. It’s a good default choice for a small positive number. You’ll learn
about other number types in Chapter 3. Additionally, the `u32` annotation in
this example program and the comparison with `secret_number` means that Rust
will infer that `secret_number` should be a `u32` as well. So now the
comparison will be between two values of the same type!
-->
<p><a href="../../std/primitive.str.html#method.parse">文字列の<code>parse</code>メソッド</a><!-- ignore -->は、文字列を解析して何らかの数値にします。
このメソッドは、いろんな数値型を解析できるので、<code>let guess: u32</code>としてコンパイラに私たちが求めている型をズバリ示唆する必要があるのです。
<code>guess</code>の後のコロン(<code>:</code>)がコンパイラに変数の型を注釈する合図になります。
Rustには、組み込みの数値型がいくつかあります; ここの<code>u32</code>型は、32ビットの非負整数です。
<code>u32</code>型は小さな非負整数のデフォルトの選択肢として丁度良いです。他の数値型については、第3章で学ぶでしょう。
付け加えると、このサンプルプログラムの<code>u32</code>という注釈と<code>secret_number</code>変数との比較は、
<code>secret_number</code>変数も<code>u32</code>型であるとコンパイラが推論することを意味します。
従って、今では比較が同じ型の2つの値で行われることになるわけです！</p>
<!--
The call to `parse` could easily cause an error. If, for example, the string
contained `A👍%`, there would be no way to convert that to a number. Because it
might fail, the `parse` method returns a `Result` type, much as the `read_line`
method does (discussed earlier in “Handling Potential Failure with the Result
Type”). We’ll treat this `Result` the same way by using the `expect` method
again. If `parse` returns an `Err` `Result` variant because it couldn’t create
a number from the string, the `expect` call will crash the game and print the
message we give it. If `parse` can successfully convert the string to a number,
it will return the `Ok` variant of `Result`, and `expect` will return the
number that we want from the `Ok` value.
-->
<p><code>parse</code>メソッドの呼び出しは、エラーになりやすいです。例としては、文字列が<code>A👍%</code>を含んでいたら、
数値に変換できるわけがありません。失敗する可能性があるので、<code>parse</code>メソッドは、
<code>Result</code>型を返すわけです。ちょうど、(「Result型で失敗する可能性に対処する」節で先ほど議論した)<code>read_line</code>メソッドのようにというわけですね。
今回も、<code>expect</code>メソッドを使用して<code>Result</code>型を同じように扱います。この<code>Result</code>を<code>expect</code>メソッドを再度使用して、
同じように扱います。もし、文字列から数値を生成できなかったために、<code>parse</code>メソッドが<code>Result</code>型の<code>Err</code>列挙子を返したら、
<code>expect</code>メソッドの呼び出しは、ゲームをクラッシュさせ、与えたメッセージを表示します。
もし、<code>parse</code>メソッドが文字列の数値への変換に成功したら、<code>Result</code>型の<code>Ok</code>列挙子を返し、
<code>expect</code>メソッドは、<code>Ok</code>値から必要な数値を返してくれます。</p>
<!--
Let’s run the program now!
-->
<p>さあ、プログラムを走らせましょう！</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<!--
Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.
-->
<p>いいですね！予想の前にスペースを追加したにもかかわらず、プログラムはちゃんとユーザが76と予想したことを導き出しました。
プログラムを何回か走らせて、異なる入力の色々な振る舞いを確認してください: つまり、
数字を正しく言い当てたり、大きすぎる値を予想したり、小さすぎる数字を入力したりということです。</p>
<!--
We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!
-->
<p>ここまでで大方ゲームはうまく動くようになりましたが、まだユーザは1回しか予想できません。
ループを追加して、その部分を変更しましょう！</p>
<!--
## Allowing Multiple Guesses with Looping
-->
<h2><a class="header" href="#ループで複数回の予想を可能にする" id="ループで複数回の予想を可能にする">ループで複数回の予想を可能にする</a></h2>
<!--
The `loop` keyword creates an infinite loop. We'll add that now to give users
more chances at guessing the number:
-->
<p><code>loop</code>キーワードは、無限ループを作り出します。これを追加して、ユーザが何回も予想できるようにしましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<!--
As you can see, we’ve moved everything into a loop from the guess input prompt
onward. Be sure to indent the lines inside the loop another four spaces each
and run the program again. Notice that there is a new problem because the
program is doing exactly what we told it to do: ask for another guess forever!
It doesn't seem like the user can quit!
-->
<p>見てわかる通り、予想入力部分以降をループに入れ込みました。ループ内の行にインデントを追加するのを忘れないようにして、
またプログラムを走らせてみましょう。新たな問題が発生したことに注目してください。
プログラムが教えた通りに動作しているからですね: 永遠に予想入力を求めるわけです！
これでは、ユーザが終了できないようです！</p>
<!--
The user could always halt the program by using the keyboard shortcut <span
class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster as mentioned in the `parse` discussion in “Comparing the
Guess to the Secret Number”: if the user enters a non-number answer, the
program will crash. The user can take advantage of that in order to quit, as
shown here:
-->
<p>ユーザは、<span class="keystroke">ctrl-c</span>というキーボードショートカットを使って、いつでもプログラムを強制終了させられます。
しかし、「予想と秘密の数字を比較する」節の<code>parse</code>メソッドに関する議論で触れたように、
この貪欲なモンスターを回避する別の方法があります: ユーザが数字以外の答えを入力すれば、プログラムはクラッシュするのです。
ユーザは、その利点を活かして、終了することができます。以下のようにですね:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
(スレッド'main'は'数字を入力してください！: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
(注釈: `RUST_BACKTRACE=1`で走らせるとバックトレースを見れます)
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
(エラー: プロセスは予期なく終了しました)
</code></pre>
<!--
Typing `quit` actually quits the game, but so will any other non-number input.
However, this is suboptimal to say the least. We want the game to automatically
stop when the correct number is guessed.
-->
<p><code>quit</code>と入力すれば、実際にゲームを終了できるわけですが、別に他の数字以外の入力でもそうなります。
しかしながら、これは最低限度と言えるでしょう。正しい数字が予想されたら、自動的にゲームが停止してほしいわけです。</p>
<!--
### Quitting After a Correct Guess
-->
<h3><a class="header" href="#正しい予想をした後に終了する" id="正しい予想をした後に終了する">正しい予想をした後に終了する</a></h3>
<!--
Let’s program the game to quit when the user wins by adding a `break` statement:
-->
<p><code>break</code>文を追加して、ユーザが勝った時にゲームが終了するようにプログラムしましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
Adding the `break` line after `You win!` makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of `main`.
-->
<p><code>break</code>文の1行を<code>You win!</code>の後に追記することで、ユーザが秘密の数字を正確に予想した時に、
プログラムはループを抜けるようになりました。ついでに、ループを抜けることは、プログラムを終了することを意味します。
ループが<code>main</code>関数の最後の部分だからですね。</p>
<!--
### Handling Invalid Input
-->
<h3><a class="header" href="#不正な入力を処理する" id="不正な入力を処理する">不正な入力を処理する</a></h3>
<!--
To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where `guess`
is converted from a `String` to a `u32`, as showin in Listing 2-5.
-->
<p>さらにゲームの振る舞いを改善するために、ユーザが数値以外を入力した時にプログラムをクラッシュさせるのではなく、
非数値を無視してユーザが数当てを続けられるようにしましょう！これは、
<code>guess</code>が<code>String</code>型から<code>u32</code>型に変換される行を改変することで達成できます。リスト2-5のようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);

let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};

println!(&quot;You guessed: {}&quot;, guess);

// --snip--
</code></pre>
<!--
<span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span>
-->
<p><span class="caption">リスト2-5: 非数値の予想を無視し、プログラムをクラッシュさせるのではなく、もう1回予想してもらう</span></p>
<!--
Switching from an `expect` call to a `match` expression is how you generally
move from crash on an error to handling the error. Remember that `parse`
returns a `Result` type and `Result` is an enum that has the variants `Ok` or
`Err`. We’re using a `match` expression here, as we did with the `Ordering`
result of the `cmp` method.
-->
<p><code>expect</code>メソッドの呼び出しから<code>match</code>式に切り替えることは、
エラーでクラッシュする動作からエラー処理を行う処理に変更する一般的な手段になります。<code>parse</code>メソッドは、
<code>Result</code>型を返し、<code>Result</code>は<code>Ok</code>か<code>Err</code>の列挙子を取りうる列挙型であることを思い出してください。
ここでは<code>match</code>式を使っています。<code>cmp</code>メソッドの<code>Ordering</code>という結果のような感じですね。</p>
<!--
最後の行が日本語にしづらい
-->
<!--
If `parse` is able to successfully turn the string into a number, it will
return an `Ok` value that contains the resulting number. That `Ok` value will
match the first arm’s pattern, and the `match` expression will just return the
`num` value that `parse` produced and put inside the `Ok` value. That number
will end up right where we want it in the new `guess` variable we’re creating.
-->
<p><code>parse</code>メソッドは、文字列から数値への変換に成功したら、結果の数値を保持する<code>Ok</code>値を返します。
この<code>Ok</code>値は、最初のアームのパターンにマッチし、この<code>match</code>式は<code>parse</code>メソッドが生成し、
<code>Ok</code>値に格納した<code>num</code>の値を返すだけです。その数値が最終的に、生成している新しい<code>guess</code>変数として欲しい場所に存在します。</p>
<!--
If `parse` is *not* able to turn the string into a number, it will return an
`Err` value that contains more information about the error. The `Err` value
does not match the `Ok(num)` pattern in the first `match` arm, but it does match
the `Err(_)` pattern in the second arm. The underscore, `_`, is a
catchall value; in this example, we’re saying we want to match all `Err`
values, no matter what information they have inside them. So the program will
execute the second arm's code, `continue`, which tells the program to go to the
next iteration of the `loop` and ask for another guess. So effectively, the
program ignores all errors that `parse` might encounter!
-->
<p><code>parse</code>メソッドは、文字列から数値への変換に<em>失敗</em>したら、エラーに関する情報を多く含む<code>Err</code>値を返します。
この<code>Err</code>値は、最初の<code>match</code>アームの<code>Ok(num)</code>というパターンにはマッチしないものの、
2番目のアームの<code>Err(_)</code>というパターンにはマッチするわけです。この<code>_</code>は、包括値です; この例では、
保持している情報がどんなものでもいいから全ての<code>Err</code>値にマッチさせたいと宣言しています。
従って、プログラムは2番目のアームのコードを実行し(<code>continue</code>ですね)、これは、
<code>loop</code>の次のステップに移り、再度予想入力を求めるようプログラムに指示します。故に実質的には、
プログラムは<code>parse</code>メソッドが遭遇しうる全てのエラーを無視するようになります！</p>
<!--
Now everything in the program should work as expected. Let’s try it:
-->
<p>さて、プログラムの全てがうまく予想通りに動くはずです。試しましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<!--
Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the `println!` that outputs the
secret number. Listing 2-6 shows the final code:
-->
<p>素晴らしい！最後にひとつまみ変更を加えて、数当てゲームを完了にしましょう。
プログラムが未だに秘密の数字を出力していることを思い出してください。テスト中はうまく動くけど、
ゲームを台無しにしてしまいます。秘密の数字を出力する<code>println!</code>を削除しましょう。
リスト2-6が成果物のコードです:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-6: Complete guessing game code</span>
-->
<p><span class="caption">リスト2-6: 数当てゲームの完全なコード</span></p>
<!--
## Summary
-->
<h2><a class="header" href="#まとめ" id="まとめ">まとめ</a></h2>
<!--
At this point, you’ve successfully built the guessing game. Congratulations!
-->
<p>ここまでで、数当てゲームの構築に成功しました。おめでとうございます！</p>
<!--
This project was a hands-on way to introduce you to many new Rust concepts:
`let`, `match`, methods, associated functions, external crates, and more. In
the next few chapters, you’ll learn about these concepts in more detail.
Chapter 3 covers concepts that most programming languages have, such as
variables, data types, and functions, and shows how to use them in Rust.
Chapter 4 explores ownership, a feature that makes Rust different from other
languages. Chapter 5 discusses structs and method syntax, and Chapter 6
explains how enums work.
-->
<p>このプロジェクトは、たくさんの新しいRustの概念に触れる実践的な方法でした:
<code>let</code>、<code>match</code>、メソッド、関連関数、外部クレートの使用などなど。
以降の数章で、これらの概念についてより深く学ぶことになるでしょう。
第3章では、ほとんどのプログラミング言語に存在する、変数、データ型、関数などの概念について講義し、
それらのRustでの使用方法について示します。
第4章では、所有権について見ます。これにより、Rustは他の言語とかけ離れた存在になっています。
第5章では、構造体とメソッド記法について議論し、第6章ではenumの動作法を説明します。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        

    </body>
</html>
